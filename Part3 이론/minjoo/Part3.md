# 이론

## 22. 요소들을 유익하게 관계 맺는 일

‘소프트웨어 설계의 의미’에 대해 ‘요소들을 유익하게 관계 맺는 일’이라고 말한다

### 요소

현실에서의 물질 구조는 아래와 같다.

세포 → 기관 → 유기체

프로그래밍은 아래와 같이 구성된다.

- 토큰 → 식(expression) → 문(statement) → 함수 → 객체/모듈 → 시스템

이들을 요소라고 하며, 요소에는 경계가 있어 어디에서 시작하고 끝나는지 알 수 있다.

### 관계 맺기

자연에서 ‘~가 ~를 먹는다’라는 관계가 있듯 ‘하나의 함수가 다른 함수를 호출한다.’라는 관계를 맺는다.

소프트웨어에서의 관계는 아래와 같이 나뉜다.

- 호출
- 발행
- 대기
- 참조(변수의 값을 가져오기)

### 유익하게

리액트 같은 라이브러리도 겉보기엔 잘 동작하지만, 내부 요소 간의 복잡한 관계 때문에 빠르게 변경하기 어렵다. 중간 계층을 두면 요소들이 역할을 나누며 더 유연하게 동작할 수 있다.

결국, 잘 설계된 프로그램은 내부적으로 구조화되어 있어야 유지보수와 확장이 쉬워진다.

### 요소들을 유익하게 관계 맺는 일

소프트웨어 설계자는 다음과 같은 일만 할 수 있다.

- 요소를 만들고 삭제한다
- 관계를 만들고 삭제한다
- 관계의 이점을 높인다.

예를 들어, 객체 내부로 로직을 이동시키면 호출하는 함수는 단순해지고, 시스템의 구조가 명확해진다. 결국, 좋은 설계는 요소 간의 관계를 최적화하여 유지보수성과 확장성을 높이는 것이다.

```jsx
class User {
  constructor(private firstName: string, private lastName: string) {}

  getFullName(): string {
    return `${this.firstName} ${this.lastName}`; // 내부에서 처리
  }
}

function greet(user: User): string {
  return `Hello, ${user.getFullName()}!`; // 호출부 단순화
}

// 사용 예시
const user = new User("min", "joo");
console.log(greet(user)); // "Hello, min joo!"
```

`greet()` 함수에서 `firstName`과 `lastName`을 직접 조합했을 수도 있지만,

`User` 클래스 내부에 `getFullName()` 메서드를 추가함으로써 `greet()` 함수가 더 단순해졌다.

## 23. 구조와 동작

소프트웨어는 두 가지 가치를 추구한다.

- 현재 소프트웨어가 하는 일
- 미래에 새로운 일을 시킬 수 있는 가능성

두 가지 가치 모두 중요하지만,

**소프트웨어는 현재 기능뿐만 아니라, 미래의 변화를 쉽게 할 수 있는 능력에서 가치가 생긴다.**

좋은 구조는 기능을 더 쉽게 변경하고 확장할 수 있도록 도와주지만, 구조 자체는 눈에 잘 보이지 않기 때문에 간과되기 쉽다. 결국, 소프트웨어 설계는 선택 가능성을 유지하고 확장할 수 있도록 구조를 투자하는 것이 핵심이다.

## 24. 경제 이론: 시간 가치와 선택 가능성

소프트웨어 설계와 돈의 본성은 연결이 된다.

소프트웨어 설계도 **즉각적인 이익(현재의 기능 제공)과 미래의 유연성(변경 가능성, 확장성)을 균형 있게 조화해야 한다.**

## 25. 오늘의 1달러가 내일의 1달러보다 크다

"오늘의 소프트웨어 시스템이 내일의 시스템보다 더 가치 있다"는 의미는 아니다.

예를 들어,

- 10년 동안 1천만 달러를 투자해 2천만 달러를 버는 시스템
- 지금 1천만 달러를 벌고, 10년 뒤 2천만 달러를 지불하는 시스템

전자는 긴장이 필요하지만, 후자는 첫날부터 수익이 보장된다.

저자는 **돈의 시간 가치**를 고려해 **코드 정리는 나중에 하는 것**을 권장한다.

즉, 먼저 기능을 추가해 돈을 벌고, 이후 정리하는 방식이다.

다만, **정리하지 않는 것이 더 비싸다면 먼저 정리해야 한다.**

## 26. 옵션

소프트웨어의 경제적 가치는 **미래의 현금 흐름을 어떻게 조정하느냐**에 따라 달라진다.

즉, **더 빨리, 더 확실하게 돈을 벌고, 더 늦게, 더 적은 확률로 돈을 쓰는 것이 이상적이다.**

하지만 소프트웨어 설계는 단순한 경제 모델을 넘어선다. **변화할 가능성을 열어두는 "옵션"이 또 하나의 중요한 가치**다.

과거 금융 소프트웨어를 개발하며 옵션 가격 책정을 연구한 경험을 통해, 저자는 **소프트웨어 설계도 미래의 변화를 대비하는 과정**임을 깨달았다.

옵션을 유지하면 **미래에 더 많은 선택지가 생기고, 가치 있는 변화를 만들 가능성이 커진다.**

예를 들어, 감자를 사고팔 때, 내일 감자를 사겠다는 선택권(옵션)을 돈을 주고 살 수 있다.

소프트웨어 설계도 마찬가지다. **지금 당장 기능을 추가하는 것이 아니라, 미래에 쉽게 변경할 수 있도록 설계하는 것이 중요하다.**

이것이 **소프트웨어 설계를 옵션의 관점에서 바라봐야 한다**는 개념이다.

더 나아가, 소프트웨어 개발에서 가치는 이미 구현된 기능에서만 나오지 않는다.

오히려 "다음에 어떤 기능을 만들 수 있을까?"라는 가능성 자체도 가치가 된다.

- 동작 후보 목록이 많을수록, 즉 미래에 만들 수 있는 기능이 많을수록 시스템의 가치는 올라간다.
- 가치가 높은 기능이 무엇인지 예측하기 어렵기 때문에, 다양한 선택지를 열어두는 것이 중요하다.
- 가치에 대한 불확실성이 클수록, 즉각적인 구현보다 변화를 포용할 수 있도록 설계하는 것이 더 유리하다.

즉, **소프트웨어 개발은 지금 당장의 기능을 만드는 것이 아니라, 미래의 선택지를 극대화하는 과정**이다.

이런 관점을 가지면, 기능을 바로 구현하기보다 변경 가능성을 높이는 설계가 더 가치 있는 전략이 될 수 있다.

결국, 소프트웨어 설계는 **"즉각적인 기능 변경"과 "미래를 위한 선택지 확보" 사이에서 균형을 맞추는 과정**이다.

이 균형을 맞추는 것이야말로, 소프트웨어 설계자가 직면하는 가장 어려운 과제다.

## 27. 옵션과 현금흐름 비교

이 책에서는 "코드 정리를 먼저 해야 하는가?"라는 경제적 관점을 다룬다.

1. **코드 정리를 미루는 것이 유리할 때**
   - 현금흐름할인 관점에서는 먼저 돈을 벌고, 나중에 정리하는 것이 더 이득이다.
   - 지금 정리를 미루면, 어쩌면 나중에는 정리가 필요 없을 수도 있다.
2. **코드 정리를 먼저 해야 하는 경우**
   - 옵션 관점에서는 미래 가치를 높일 가능성이 있다면 지금 정리하는 것이 낫다.
   - 특히 동작 변경 후에도 정리할 내용이 남는다면, 먼저 정리하는 것이 좋다.
3. **코드 정리 여부를 판단하는 공식**
   - (코드 정리 비용) + (정리 후 동작 변경 비용) < (바로 동작 변경 비용)→ 이 경우 **무조건 코드 정리를 먼저 해야 한다.**
   - 반대로, 비용이 더 크다면 정리를 미루는 것이 경제적일 수 있다.
   - 하지만, 옵션의 가치가 더 크다면 코드 정리가 유리할 수도 있다.
4. **코드 정리는 단순한 경제적 판단이 아니다**
   - 코드 정리를 하면 이후 개발 과정이 더 즐거워질 수도 있다.
   - 하지만, 경제적 인센티브와 충돌할 가능성도 인식해야 한다.
5. **코드 정리의 시점을 정확히 계산할 수는 없다**
   - 몇 분~몇 시간 단위의 코드 정리는 경제성을 정확히 계산할 수 없다.
   - 대신, 적절한 설계 시점과 협업 능력을 키우는 것이 중요하다.

이런 연습을 꾸준히 하면, **언제, 어떻게 설계해야 하는지 직관적으로 판단할 수 있게 된다.**

## 28. 되돌릴 수 있는 구조 변경

되돌릴 수 있는 변경은 부담 없이 시도할 수 있지만, 되돌릴 수 없는 변경은 신중해야 한다.

잘못된 동작 변경은 되돌리는 데 큰 비용이 들 수 있으므로, 두 가지를 구분해서 접근해야 한다.

되돌리기 어려운 변경이라면, **프로토타입을 만들거나 기능 플래그를 활용해 점진적으로 적용**하는 것이 좋다.

이렇게 하면 문제가 생겼을 때 빠르게 되돌릴 수 있다.

### **설계 변경이 되돌릴 수 없게 되는 순간**

설계 변경이 코드베이스 전체로 확산되면 되돌리기 어렵다.

이런 경우 **한 번에 모든 걸 바꾸지 말고, 점진적으로 변경하는 게 최선이다.**

### **완벽한 결정은 없다, 가역성이 핵심이다**

실수를 막을 수는 없지만, 실패했을 때 되돌릴 수 있도록 설계하는 것이 더 중요하다.

결국, **유연한 구조를 유지하는 것이 최선의 전략이다.**

## 29. 결합도

- 하나의 요소를 변경하면 다른 요소도 함께 변경해야 하는 특성
- 결합도가 높을수록 유지보수 비용이 증가한다

결합도가 문제인 이유는 아래와 같다

- 일대다 문제: 하나의 변경이 여러 요소에 영향을 미친다.
- 연쇄작용: 하나의 변경이 또 다른 변경을 촉발하며 비용이 기하급수적으로 증가한다

결합도를 파악하기 위해 단순히 코드의 관계를 보는 것이 아니라, 어떤 변경과 관련하여 결합되었는지를 분석해야 한다.

> “내가 이것을 바꾸면 , 저것들 모두를 바꾸어야 하잖아. 너무 끔찍해 "
> 잠시 시간을 내어 코드 정리 카탈로그를 살펴보고 , 어떤 것이 결합도를 줄일 수 있는지 살펴보세요.

## 30. 콘스탄틴의 등가성

소프트웨어 비용의 70%는 유지보수, 즉 변경하는 데서 발생한다.

결국, **변경 비용이 곧 소프트웨어 비용**이며, 변경이 많아질수록 총비용도 증가한다.

작은 변경들은 큰 문제가 되지 않지만, 큰 변경이 발생하면 비용이 기하급수적으로 증가한다.

그 이유는 변경이 여러 요소로 전파되면서 결합도가 높은 시스템에서는 수정할 부분이 계속 늘어나기 때문이다.

따라서, **소프트웨어 비용을 줄이려면 결합도를 낮추는 것이 필수적**이다.

하지만 결합도를 낮추는 것은 단순한 일이 아니며, 현실적인 절충이 필요하다.

💡 **비용 ( 소프트웨어 ) ~ = 결합도**

## 31. 결합도와 결합도 제거

결합도는 완전히 제거할 수 없으며, 때로는 필요하기도 하다.

처음 개발할 때는 빠르게 구현하는 것이 중요하기 때문에, 어느 정도의 결합도를 감수하는 것이 경제적으로 유리할 수도 있다.

하지만 시간이 지나면 유지보수 과정에서 결합도가 문제로 드러나고, 변경 비용이 점점 커진다.

결합도를 줄이면 특정 변경이 쉬워지지만, 반대로 다른 변경이 더 어려워질 수도 있다.

```jsx
// 결합도가 높은 코드
class Sender {
  send() {
    this.writeField1();
    this.writeField2();
  }
}

class Receiver {
  receive() {
    this.readField1();
    this.readField2();
  }
}

// 결합도를 줄인 코드
interface FieldFormat {
  field: string;
  type: "integer" | "string";
}

// 송수신할 데이터 형식 설정
const format: FieldFormat[] = [
  { field: "1", type: "integer" },
  { field: "2", type: "string" },
];

// Sender 클래스 (데이터를 보내는 역할)
class Sender {
  send(data: Record<string, any>): string {
    return JSON.stringify(data);
  }
}

// Receiver 클래스 (데이터를 받는 역할)
class Receiver {
  receive(serializedData: string): Record<string, any> {
    return JSON.parse(serializedData);
  }
}
```

모든 결합을 제거하려고 애쓰기보다는, **어떤 결합을 유지하고 어떤 결합을 줄일지 신중하게 결정해야 한다.**

결국, 결합도를 줄이는 데 드는 비용과 그대로 유지할 때의 비용을 비교하면서, **가장 적절한 절충점을 찾는 것이 핵심이다.**

## 32. 응집도

응집도가 높다는 것은 관련 있는 요소들이 함께 모여 있고, 불필요한 요소들은 다른 곳으로 이동해야 한다는 의미다.

모듈 내에서 일부 함수들이 강하게 결합되어 있다면, 이를 **별도의 하위 모듈로 묶어 응집도를 높이는 방법**이 있다.

또는, 결합되지 않은 요소들을 적절한 위치로 이동하여 정리할 수도 있다.

하지만, **즉흥적인 대규모 재배치는 위험**하다.

한 번에 한 요소씩 정리하면서, 다음 사람이 쉽게 이해할 수 있도록 개선하는 것이 중요하다.

이런 작은 정리가 쌓이면, 결국 더 좋은 코드가 만들어진다.

## 33. 결론

이제 책의 핵심 질문인 "코드 정리가 먼저인가?"에 답할 차례다.

이 질문은 단순하지 않으며, 다음 네 가지 요소에 의해 결정된다.

1. **비용** – 지금 정리하면 비용이 줄어들까, 아니면 나중이 더 나을까?
2. **수익** – 코드 정리가 수익을 더 크게, 혹은 더 빨리 만들 수 있을까?
3. **결합도** – 코드 정리를 하면 변경해야 할 요소의 수가 줄어들까?
4. **응집도** – 코드 정리를 하면 변경을 더 작은 범위에 집중시킬 수 있을까?

코드 정리는 단순한 경제적 판단이 아니다.

개발을 더 즐겁게 하고, 더 나은 프로그래머가 되는 데도 영향을 미친다.

하지만 지나친 코드 정리는 위험하다.

끝없이 정리하다 보면 기능 개발이 지연되거나, 동료들의 작업을 방해할 수도 있다.

따라서 **코드 정리는 다음 변경을 원활하게 하기 위한 수단**이어야 하며, **언제, 얼마나 정리할지 균형을 맞추는 것이 중요하다.**

이 책은 개인을 위한 코드 정리를 다루지만, 결국 소프트웨어 설계는 협업과 비즈니스의 균형에서도 중요한 역할을 한다.

**코드 정리는 언제나 가치 있는가?**

아마도 그렇다. **적절한 시점과 목적을 이해하고 실행한다면.**
