# Chapter 22: 요소들을 유익하게 관계 맺는 일

## 1.1 **주요 개념**
- **소프트웨어 설계에서의 관계**: 호출, 발행, 대기, 참조(변수의 값을 가져오기)와 같은 관계가 존재한다.

## 1.2 **핵심 메시지**
- 소프트웨어 요소들이 올바르게 관계를 맺는 것이 설계의 핵심이다.

## 1.3 **생각해볼 질문**
- 소프트웨어 요소 간 관계를 최적화하기 위한 방법은 무엇인가?
- 관계가 잘못 형성될 경우 발생할 수 있는 문제는?

---

# Chapter 23: 구조와 동작

## 1.1 **주요 개념**
- **구조**: 소프트웨어의 정적인 부분.
- **동작**: 실제 가치를 만들어내는 동적인 부분.

## 1.2 **핵심 메시지**
- "동작은 가치를 만든다."

## 1.3 **생각해볼 질문**
- 소프트웨어에서 구조보다 동작이 더 중요한 이유는 무엇인가?
- 코드 정리(구조 개선)와 동작 변경의 균형을 어떻게 맞출 수 있을까?

---

# Chapter 24: 경제 이론 – 시간 가치와 선택 가능성

## 1.1 **주요 개념**
- **시간 가치**: 미래보다 현재의 자원이 더 큰 가치를 지닌다.
- **선택 가능성**: 미래에 더 나은 선택을 할 수 있도록 유연성을 확보해야 한다.

## 1.2 **핵심 메시지**
- 소프트웨어 설계에서도 경제적 개념이 중요하다.

## 1.3 **생각해볼 질문**
- 소프트웨어 개발에서 선택 가능성을 극대화하는 방법은?
- 시간 가치가 코드 정리 우선순위에 미치는 영향은?

---

# Chapter 25: 오늘의 1달러가 내일의 1달러보다 크다

## 1.1 **주요 개념**
- **현재의 가치**: 미래의 수익보다 현재의 이익을 우선시해야 할 때가 많다.

## 1.2 **핵심 메시지**
- "지금의 코드 정리가 미래보다 더 가치 있을 수 있다."

## 1.3 **생각해볼 질문**
- 코드 정리를 지금 할 것인가, 나중으로 미룰 것인가?
- 기술 부채를 줄이기 위한 최적의 전략은?

---

# Chapter 26: 옵션

## 1.1 **주요 개념**
- **옵션(선택권) 유지**: 코드 변경의 유연성을 확보하는 것이 중요하다.

## 1.2 **핵심 메시지**
- "미래의 불확실성을 고려해 옵션을 남겨두자."

## 1.3 **생각해볼 질문**
- 코드에서 선택 가능성을 유지하는 방법은?
- 너무 많은 선택지가 오히려 혼란을 초래할 수 있을까?

---

# Chapter 27: 옵션과 현금흐름 비교

## 1.1 **주요 개념**
- 코드 정리 비용과 동작 변경 비용을 비교하여 우선순위를 정해야 한다.
-
    - 비용 (코드정리) + 비용 (코드 정리 후 동작 변경) < 비용 (바로 동작 변경) → 코드 정리 우선
    - 비용 (코드정리) + 비용 (코드 정리 후 동작 변경) > 비용 (바로 동작 변경) → 판단 필요

## 1.2 **핵심 메시지**
- "무조건 코드 정리를 먼저 해야 하는 것이 아니다. 상황을 분석해야 한다."

## 1.3 **생각해볼 질문**
- 코드 정리를 해야 할 적절한 시점은 언제인가?
- 코드 정리와 기능 개발의 균형을 맞추는 방법은?

---

# Chapter 28: 되돌릴 수 있는 구조 변경

## 1.1 **주요 개념**
- 되돌릴 수 있는 결정과 되돌릴 수 없는 결정은 다르게 다뤄야 한다.
- 되돌릴 수 없는 결정은 신중하게 내려야 한다.

## 1.2 **핵심 메시지**
- "대부분의 소프트웨어 설계 결정은 되돌릴 수 있다."

## 1.3 **생각해볼 질문**
- 되돌릴 수 없는 결정을 내릴 때 고려해야 할 요소는?
- 되돌릴 수 있는 구조 변경을 더 쉽게 만드는 방법은?

---

# Chapter 29: 결합도

## 1.1 **주요 개념**
- 결합도는 코드 변경 비용을 결정하는 중요한 요소이다.
- 결합도는 크게 두 가지로 나뉜다:
    1. 일대다 관계: 하나의 변경이 여러 요소에 영향을 미침.
    2. 연쇄 작용: 한 요소의 변경이 연속적인 변경을 일으킴.

## 1.2 **핵심 메시지**
- "결합도가 높으면 변경 비용이 커진다."

## 1.3 **생각해볼 질문**
- 결합도를 낮추는 방법은 무엇인가?
- 결합도를 완전히 제거할 필요가 없는 이유는?

---

# Chapter 30: 콘스탄티의 등가성

## 1.1 **주요 개념**
- 소프트웨어 비용을 줄이려면 결합도를 줄여야 한다.

## 1.2 **핵심 메시지**
- "결합도를 줄이면 유지보수 비용이 낮아진다."

## 1.3 **생각해볼 질문**
- 결합도를 줄이는 것이 항상 최선일까?
- 결합도를 줄이는 과정에서 발생할 수 있는 부작용은?

---

# Chapter 31: 결합도와 결합도 제거

## 1.1 **주요 개념**
- 결합도가 필요할 때도 있다. (예: 비용과 수익 고려, 피할 수 없는 결합도 등)

## 1.2 **핵심 메시지**
- "모든 결합을 없애려고 애쓸 필요는 없다."

## 1.3 **생각해볼 질문**
- 불필요한 결합도와 필요한 결합도의 차이는?
- 결합도를 낮추는 것이 항상 바람직한가?

---

# Chapter 32: 응집도

## 1.1 **주요 개념**
- 응집도가 높을수록 코드 변경이 쉬워진다.

## 1.2 **핵심 메시지**
- "응집도가 높으면 유지보수성이 향상된다."

## 1.3 **생각해볼 질문**
- 높은 응집도를 유지하면서 결합도를 낮추는 방법은?
- 응집도를 높이기 위한 리팩토링 기법은?

---

# Chapter 33: 결론

## 1.1 **주요 개념**
- 코드 정리는 비용, 수익, 결합도, 응집도에 의해 결정된다.

## 1.2 **핵심 메시지**
- "코드 정리는 지속적인 과정이다."

## 1.3 **생각해볼 질문**
- 코드 정리를 언제 해야 할까?
- 다른 개발자들과 협력할 때 코드 정리를 어떻게 진행해야 할까?

